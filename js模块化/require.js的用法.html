
<!DOCTYPE html>
<html>
<head>
<title>require.js的用法</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<base href='file:\\\F:\Frontend-Knowledge\js模块化\'/>
</head>
<body>
<p><link href="http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css" rel="stylesheet">
<script src="http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js"></script>
<script >hljs.initHighlightingOnLoad();</script></p>
<!-- http://tech.pro/blog/1561/five-helpful-tips-when-using-requirejs-->
<h2>require.js的用法</h2>
<h3>一、js模块的写法</h3>
<blockquote>
<p>在复杂的逻辑下，javascript需要被模块化，模块需要封装起来，只留下供外界调用的API。</p>
</blockquote>
<p><strong>① Privileged Method</strong></p>
<pre><code>function Human(sgender){
    //Private
    var age = 1,
    gender = sgender || 'Male';

    //Privileged Method
    this.growUp = function() {
        age++;
    }
}
</code></pre>

<p><strong>② Module Pattern</strong></p>
<pre><code>function Human(sgender) {
    //Private
    var age = 1,
    gender = sgender || 'Male';

    //Public
    return {
        growUp: function() {
            age++;
        }
    };
}
</code></pre>

<h3>二、AMD规范</h3>
<p><strong>AMD</strong>是“Asynchronous Module Definition”的缩写，意思就是“<strong>异步模块定义</strong>”（通过异步方式加载模块）。
使模块和它的依赖可以被异步加载，并且又可以按照正确的顺序去加载。</p>
<h4>1. AMD模式的优点</h4>
<ul>
<li>定义模块的方法更清晰，更少污染全局环境，能够清楚地显示依赖关系。</li>
<li>直接支持客户端的浏览器环境。</li>
<li>允许非同步加载模块，也可以根据需要动态加载模块</li>
</ul>
<p><code>RequireJS 遵循的是 AMD（异步模块定义）规范。</code>
管理模块之间的依赖性，便于代码的编写和维护。</p>
<h4>2. AMD规范：</h4>
<p><strong>define(id?, dependencies?, factory)</strong>
定义一个模块。它包含三个参数，前两个参数都是可选的。
一个完整的模块定义包含模块名称，模块的依赖和回调函数</p>
<ul>
<li>第一个参数 id：是一个string字符串，它表示模块的标识（也就是模块的路径，通过id才能知道从什么位置去加载依赖的模块）</li>
<li>第二个参数 dependencies：是一个数组，成员是依赖模块的:id</li>
<li>
<p>第三个参数 factory：是一个回调函数，在依赖的模块加载成功后，会执行这个回调函数，它的参数是所有依赖模块的引用，如果回调函数有返回值，会导出出来</p>
<p>define('adder', ['math'], function(math) {
    return {
        addTen: function(x) {
            return math.add(x, 10);
        }
    };
});</p>
</li>
</ul>
<h4>匿名模块</h4>
<blockquote>
<p>在实际中，使用的更多的是匿名模块定义方式，因为这样更加的灵活，模块的标识和它的源代码不在相关，开发人员可以把这个模块放在任意的位置而不需要修改代码。一般只要在使用工具打包模块到一个文件中时，才会声明第一个参数，所以应该尽量避免给模块命名。</p>
</blockquote>
<p>如果这个模块并没有依赖，那么默认的依赖是[&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]</p>
<pre><code>define([&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;], function(require, exports, module) {
    console.log(exports);   //{}
    exports.addTem = function(x) {
        return x + 10;
    }
    //or
    //module.exports.addTemfunction(x) {
    //    return x + 10;
    //}
});
</code></pre>

<p>Dependencies that can not be evalluated until runtime or only loaded when a specific event occurs;</p>
<pre><code>defind(function() {
    var isReady = false,
        foobar;
    require(['foo', 'bar'], function(foo, bar) {
        isReady = true;
        foobar = foo() + bar();
    });
    return {
        isReady: isReady,
        foobar: foobar
    };
});
</code></pre>

<h3>三、requireJS的使用</h3>
<h4>1.</h4>
<p><code>&lt;script data-main=&quot;js/main&quot; src=&quot;js/require.js&quot;&gt;&lt;/script&gt;</code>
data-main 属性告诉 require.js 在 require.js  加载之后加载 js/main.js </p>
<p>RequireJS 查找脚本的路径，主要是通过 baseUrl，在 data-main 中，声明了 baseUrl 的路径，在这句代码里也就是 js 文件夹；如果不声明 data-main，则 baseUrl 默认指向这个 html 页面所在的文件夹。当然，也可以通过配置来声明 baseUrl</p>
<h4>2.</h4>
<p>在 main.js 中，可以通过 require() 加载依赖的脚本，这样不用在 html 中显示声明.main.js 相当于是一个入口点</p>
<pre><code>require(['helper/util'], function(util) {
    // 当 scripts/helper/util.js 加载完毕，会执行这个回调函数
    // 如果 util.js 也声明了依赖的文件（模块），那么这个函数会等到那些依赖的文件（模块）加载完毕后才调用
});
</code></pre>

<p>注意，data-main 中声明的模块会被异步加载，也就意味着如果页面后面通过script标签加载多个脚本，这些脚本不一定在 data-main 中声明的模块加载之后才加载；或者后面的js代码如果有对 data-main 中声明的模块的依赖，则有可能会出现错误。</p>
<h4>3.</h4>
<p>RequireJS 会假定所有依赖项默认都是脚本，所以书写依赖时可以省略 “.js”后缀，RequireJS 会自动加上这个后缀。
RequireJS 会自动把模块ID翻译成一个路径（path），我们也可以在配置中声明多个路径（paths），通过 baseUrl + paths，可以用很少的代码找到相应的 js 文件，比起script标签要优雅简洁很多。
如：baseUrl: 'js'
    require(['helper/util'], function() {})
则：src='js/helper/util.js'</p>
<p>一般来说，通过 baseUrl + paths 就可以找到js文件，不过有时候，可能会有例外，一旦 RequireJS 发现模块 ID 中包含如下的字符，那么它就不按照 baseUrl + paths 的方式来寻找这个模块的js文件了，而是采用 URL 的方式：</p>
<ul>
<li>如果 ID 以 “.js” 结尾</li>
<li>如果 ID 以 “/” 开头</li>
<li>如果 ID 以 “http:” 或者 “https:” 开头</li>
</ul>
<p>一般来说，最好使用 baseUrl + paths 的方式来声明模块ID，这样做会有更多的灵活性。同样的，我们在组织js代码文件的时候，尽量避免使用很深的路径，而最好把js文件都放置在 baseUrl 下面，最好不要超过两层的深度</p>
<h4>4. 加载模块</h4>
<pre><code>requirejs.config({
    //默认从 js/lib 中加载模块
    baseUrl : 'js/lib',

    //如果模块ID以app开头，则会在 js/app 目录下寻找
    //不过要注意千万不要加上 &quot;.js&quot;，否则paths的规则就会失效
    paths : {
        app : '../app'
    }
});



requirejs(['jquery', 'aModule', 'bModule'],
    function ($, myFunctionA, myFunctionB) {
        //jQuery, aModule 和 bModule 模块都加载完毕后，会执行这个函数

        //TODO
    }
);
</code></pre>

<h4>5. 定义模块</h4>
<p>RequireJS 要求一个js文件只定义一个模块。
每加载一个模块，就会产生一个HTTP请求，RequireJS 提供了一个优化工具（r.js）</p>
<ul>
<li>
<p>定义一个只有键值对，没有任何依赖的模块</p>
<p>define({
    color: 'black',
    size: 'M'
});</p>
</li>
<li>
<p>定义一个函数，没有依赖</p>
<p>define(function() {
    //TODO
    return {
        color: 'black',
        size: 'M'
    }
});</p>
</li>
</ul>
<p>定义一个有依赖的函数，第一个参数是依赖的模块ID数组，后面是回调函数，会在所有依赖加载完毕后执行：</p>
<pre><code>define(['cart'], function(cart) {
    //TODO
    return {
        color: 'blue',
        size: 'M',
        addToCart: function() {
            cart.add(this);
        }
    };
});
</code></pre>

<p>当然不一定只是返回Object，也可以返回一个函数：</p>
<pre><code>define(['cart'], function(cart) {
     return function(title) {
         return title ? (window.title = title) : cart.name;
     };
});
</code></pre>

<h4>6. RequireJS工作原理</h4>
<p>RequireJS 采用 head.appendChild() 的方式来加载所有依赖的脚本</p>
<pre><code>function loadjscssfile(filename, filetype) {
    if (filetype == &quot;js&quot;) { //作为js文件载入
        var fileref = document.createElement('script')
        fileref.setAttribute(&quot;type&quot;, &quot;text/javascript&quot;)
        fileref.setAttribute(&quot;src&quot;, filename)
    }
    else if (filetype == &quot;css&quot;) {  //作为css文件载入
        var fileref = document.createElement(&quot;link&quot;)
        fileref.setAttribute(&quot;rel&quot;, &quot;stylesheet&quot;)
        fileref.setAttribute(&quot;type&quot;, &quot;text/css&quot;)
        fileref.setAttribute(&quot;href&quot;, filename)
    }
    if (typeof fileref != &quot;undefined&quot;)
        document.getElementsByTagName(&quot;head&quot;)[0].appendChild(fileref)
}

loadjscssfile(&quot;myscript.js&quot;, &quot;js&quot;)
loadjscssfile(&quot;javascript.php&quot;, &quot;js&quot;)
loadjscssfile(&quot;mystyle.css&quot;, &quot;css&quot;)
</code></pre>

<h4>7. 加载非规范的模块</h4>
<p>在加载没有实现AMD规范的模块时，RequireJS 也提供了简洁的方式，就是通过配置定义这些模块的特征</p>
<pre><code>requirejs.config({
    // 要使用 shim 来配置没有实现 AMD 规范的模块
    // 不过注意 shim 不能用来配置已经实现 AMD 规范的模块
    shim : {
        'backbone' : {
            //定义依赖，会在 backbone.js 载入前载入这些依赖
            deps : ['underscore', 'jquery'],
            //导出 Backbone
            exports : 'Backbone'
        },
        'underscore' : {
            exports : '_'
        }
    }
});

//jQuery

requirejs.config({
    shim : {
        'jquery,colorize' : {
            deps : ['jquery'],
            exports: 'jQuery.fn.colorize'
        },
        'jquery.scroll' : {
            deps : ['jquery'],
            exports : 'jQuery.fn.scroll'
        }
    }
});
</code></pre>


</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
